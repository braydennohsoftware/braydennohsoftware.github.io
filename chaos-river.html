---
layout: default
title:  Meander Cutoffs Induce Chaos
---

<p>
<a href="index.html">Brayden Noh</a>
</p>

<h1>Meander Cutoffs Induce Chaos</h1>
<h3>by Brayden Noh and Omar Wani</h3>

<p>
Lowland rivers are dynamic systems whose evolution is largely governed by the gradual growth of meander bends and episodic <a href="https://en.wikipedia.org/wiki/Meander_cutoff">cutoff</a> events that abruptly reshape its geometry. We asked a simple question: are cutoffs enough to make river evolution chaotic?
</p>

<p>
To test this, we ran pairs of simulations using <a href="https://github.com/zsylvester/meanderpy"><i>meanderpy</i></a>, a kinematic meander model where lateral migration is driven by curvature. Each pair starts from nearly identical initial conditions and simulate 10,000 years of evolution.
</p>

<p>
The challenge is that the river geometry changes length over time, so we can't directly compare two Lagrangian state vectors. Instead, we map each centerline onto a fixed Eulerian grid of binary cells: channel (1) or floodplain (0), which gives us a fixed-dimensional state for comparison.
</p>

<img src="assets/fig1-lagrangian-eulerian.png" alt="Lagrangian and Eulerian representations of the meander model" style="width: 100%; margin: 1em 0;">

<p style="font-size: 85%; color: #767676;">
<b>Figure 1.</b> (a) 100 ensemble centerlines in Lagrangian form. (b&ndash;d) The same state mapped onto Eulerian grids at 10 m, 50 m, and 100 m resolution.
</p>

<p>
We measure divergence between two runs using the Hamming distance \(d_H(t) = \|\mathbf{S}^*(t) - \mathbf{S}(t)\|_1\), which counts the number of grid cells that differ. If this grows exponentially, the system is chaotic. The rate of growth is the finite-time Lyapunov exponent:
</p>

\[\lambda_{\text{FT}} = (t_2 - t_1)^{-1} \ln\!\left[\frac{d_H(t_2)}{d_H(t_1)}\right]\]

<p>
The result is clean. With cutoffs disabled, the two trajectories remain identical &mdash; \(d_H(t) = 0\) for the entire run. With cutoffs enabled, they diverge exponentially. The video below shows this divergence in action:
</p>

<!-- Interactive Chaos-River Divergence Simulator -->
<div id="chaos-sim" style="margin: 1em 0;">
  <div style="display:flex; flex-wrap:wrap; align-items:center; gap:0.5em 0.8em; margin-bottom:0.5em; font-size:80%;">
    <button id="chaos-play" style="padding:0.2em 0.8em; cursor:pointer;">&#9654; Play</button>
    <button id="chaos-reset" style="padding:0.2em 0.8em; cursor:pointer;">Reset</button>
    <input type="range" id="chaos-scrub" min="0" max="200" value="0" style="flex:1; min-width:120px;">
    <label style="white-space:nowrap;">Delay: <input type="range" id="chaos-delay" min="0" max="200" value="50" style="width:60px; vertical-align:middle;"> <span id="chaos-delay-val">50</span>ms</label>
    <label style="white-space:nowrap;">Grid: <input type="range" id="chaos-grid" min="10" max="100" step="5" value="50" style="width:70px; vertical-align:middle;"> <span id="chaos-grid-val">50</span> m</label>
  </div>
  <div style="position:relative; line-height:0;">
    <canvas id="chaos-canvas" width="720" height="360" style="width:100%; background:#1a1a2e; display:block; image-rendering:pixelated; image-rendering:crisp-edges;"></canvas>
    <div id="chaos-loading" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;font-size:90%;">Loading data&hellip;</div>
  </div>
  <div style="display:flex; align-items:center; gap:0.4em; margin-top:0.3em;">
    <span style="font-size:75%; color:#767676;">0</span>
    <canvas id="chaos-colorbar" width="200" height="12" style="max-width:200px;"></canvas>
    <span style="font-size:75%; color:#767676;">100</span>
    <span style="font-size:75%; color:#767676; margin-left:0.3em;">ensemble occupancy</span>
  </div>
  <div id="chaos-info" style="font-size:75%; color:#767676; margin-top:0.2em;">Loading&hellip;</div>
</div>

<p style="font-size: 85%; color: #767676;">
<b>Figure 2.</b> Interactive Eulerian occupancy heatmap of 100 ensemble simulations with cutoffs enabled. Drag the grid slider to change resolution continuously (10&ndash;100 m); scrub through time to see trajectories diverge.
</p>

<script>
(function () {
  "use strict";

  var SKIP = 10; /* skip first 10 frames (artefacts before cutoffs kick in) */

  var state = {
    grids: null,   /* flat Uint8Array: n_timesteps * BASE_ROWS * BASE_COLS */
    meta: null,
    lut: null,     /* RGBA colormap, 101 entries */
    gridSize: 50,  /* current display resolution (m) */
    frame: SKIP,
    playing: false,
    timer: null,
    delay: 50
  };

  var canvas = document.getElementById("chaos-canvas");
  var ctx = canvas.getContext("2d");
  var loadingEl = document.getElementById("chaos-loading");

  /* HiDPI: size canvas to actual device pixels for crisp rendering */
  var dpr = window.devicePixelRatio || 1;
  function sizeCanvas() {
    var rect = canvas.getBoundingClientRect();
    canvas.width  = Math.round(rect.width  * dpr);
    canvas.height = Math.round(rect.height * dpr);
  }
  sizeCanvas();
  window.addEventListener("resize", function () { sizeCanvas(); renderFrame(); });

  /* off-screen buffer sized to the output grid */
  var buf = document.createElement("canvas");
  var bufCtx = buf.getContext("2d");

  /* ---- load PNG sprite-sheet + JSON metadata ---- */
  function loadAll(cb) {
    var metaDone = false, imgDone = false;
    var metaObj, spriteImg;

    /* metadata */
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "assets/chaos_meta.json");
    xhr.onload = function () {
      metaObj = JSON.parse(xhr.responseText);
      metaDone = true;
      if (imgDone) finish();
    };
    xhr.send();

    /* sprite PNG */
    spriteImg = new Image();
    spriteImg.onload = function () {
      imgDone = true;
      if (metaDone) finish();
    };
    spriteImg.src = "assets/chaos_occupancy.png";

    function finish() {
      var m = metaObj;
      var BC = m.base_cols, BR = m.base_rows, TPR = m.tiles_per_row;
      var N = m.n_timesteps;

      /* draw sprite to off-screen canvas, extract R channel */
      var tmp = document.createElement("canvas");
      tmp.width = spriteImg.width;
      tmp.height = spriteImg.height;
      var tmpCtx = tmp.getContext("2d");
      tmpCtx.drawImage(spriteImg, 0, 0);
      var full = tmpCtx.getImageData(0, 0, tmp.width, tmp.height).data;

      var grids = new Uint8Array(N * BR * BC);
      for (var i = 0; i < N; i++) {
        var tc = i % TPR, tr = (i / TPR) | 0;
        var tileY = tr * BR, tileX = tc * BC;
        for (var r = 0; r < BR; r++) {
          var srcOff = ((tileY + r) * tmp.width + tileX) * 4;
          var dstOff = i * BR * BC + r * BC;
          for (var c = 0; c < BC; c++) {
            grids[dstOff + c] = full[srcOff + c * 4]; /* R channel */
          }
        }
      }
      state.grids = grids;
      state.meta = m;

      /* build RGBA LUT */
      var cmap = m.colormap;
      var lut = new Uint8Array(101 * 4);
      for (var v = 0; v <= 100; v++) {
        lut[v * 4]     = cmap[v * 3];
        lut[v * 4 + 1] = cmap[v * 3 + 1];
        lut[v * 4 + 2] = cmap[v * 3 + 2];
        lut[v * 4 + 3] = 255;
      }
      state.lut = lut;

      cb();
    }
  }

  /* ---- rendering: downsample from base grid via block-max ---- */
  function renderFrame() {
    if (!state.grids) return;
    var m = state.meta, lut = state.lut;
    var BC = m.base_cols, BR = m.base_rows;
    var G = state.gridSize, B = G / m.base_cell;
    var outCols = Math.floor((m.xmax - m.xmin) / G);
    var outRows = Math.floor((m.ymax - m.ymin) / G);
    var frameOff = state.frame * BR * BC;

    /* resize off-screen buffer */
    if (buf.width !== outCols || buf.height !== outRows) {
      buf.width = outCols; buf.height = outRows;
    }
    var imgData = bufCtx.createImageData(outCols, outRows);
    var px = imgData.data;

    for (var r = 0; r < outRows; r++) {
      var srcR0 = Math.floor(r * B);
      var srcR1 = Math.min(Math.floor((r + 1) * B), BR);
      var dispR = outRows - 1 - r; /* flip y */

      for (var c = 0; c < outCols; c++) {
        var srcC0 = Math.floor(c * B);
        var srcC1 = Math.min(Math.floor((c + 1) * B), BC);

        /* block-max */
        var maxV = 0;
        for (var sr = srcR0; sr < srcR1; sr++) {
          var rowOff = frameOff + sr * BC;
          for (var sc = srcC0; sc < srcC1; sc++) {
            var v = state.grids[rowOff + sc];
            if (v > maxV) maxV = v;
          }
        }

        var li = maxV * 4, di = (dispR * outCols + c) * 4;
        px[di] = lut[li]; px[di+1] = lut[li+1]; px[di+2] = lut[li+2]; px[di+3] = 255;
      }
    }
    bufCtx.putImageData(imgData, 0, 0);

    /* scale to display canvas (nearest-neighbour, HiDPI-aware) */
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(buf, 0, 0, canvas.width, canvas.height);

    updateInfo();
  }

  function updateInfo() {
    var m = state.meta;
    if (!m) return;
    var t = state.frame * m.step;
    var yr = (t * m.dt_years).toFixed(1);
    var maxT = (m.n_timesteps - 1) * m.step;
    document.getElementById("chaos-info").textContent =
      "Timestep: " + t + " / " + maxT +
      "  |  Time: " + yr + " yr  |  Grid: " + state.gridSize + " m";
  }

  /* ---- colorbar ---- */
  function drawColorbar() {
    if (!state.lut) return;
    var cb = document.getElementById("chaos-colorbar");
    var cbCtx = cb.getContext("2d");
    var w = cb.width, h = cb.height;
    var img = cbCtx.createImageData(w, h);
    var lut = state.lut;
    for (var x = 0; x < w; x++) {
      var val = Math.round(x / (w - 1) * 100);
      var li = val * 4;
      for (var y = 0; y < h; y++) {
        var di = (y * w + x) * 4;
        img.data[di] = lut[li]; img.data[di+1] = lut[li+1];
        img.data[di+2] = lut[li+2]; img.data[di+3] = 255;
      }
    }
    cbCtx.putImageData(img, 0, 0);
  }

  /* ---- playback ---- */
  function step() {
    if (!state.meta) return;
    if (state.frame < state.meta.n_timesteps - 1) {
      state.frame++;
      scrubEl.value = state.frame;
      renderFrame();
    } else {
      pause();
    }
  }

  function play() {
    if (state.playing) return;
    state.playing = true;
    playBtn.innerHTML = "&#9646;&#9646; Pause";
    tick();
  }

  function tick() {
    if (!state.playing) return;
    step();
    if (state.playing) state.timer = setTimeout(tick, state.delay);
  }

  function pause() {
    state.playing = false;
    playBtn.innerHTML = "&#9654; Play";
    if (state.timer) { clearTimeout(state.timer); state.timer = null; }
  }

  function reset() {
    pause();
    state.frame = SKIP;
    scrubEl.value = SKIP;
    renderFrame();
  }

  /* ---- controls ---- */
  var playBtn = document.getElementById("chaos-play");
  var scrubEl = document.getElementById("chaos-scrub");
  var delayEl = document.getElementById("chaos-delay");
  var delayVal = document.getElementById("chaos-delay-val");
  var gridSlider = document.getElementById("chaos-grid");
  var gridVal = document.getElementById("chaos-grid-val");
  playBtn.addEventListener("click", function () {
    state.playing ? pause() : play();
  });
  document.getElementById("chaos-reset").addEventListener("click", reset);

  scrubEl.addEventListener("input", function () {
    state.frame = parseInt(this.value, 10);
    renderFrame();
  });

  delayEl.addEventListener("input", function () {
    state.delay = parseInt(this.value, 10);
    delayVal.textContent = this.value;
  });

  gridSlider.addEventListener("input", function () {
    state.gridSize = parseInt(this.value, 10);
    gridVal.textContent = this.value;
    renderFrame();
  });

  /* ---- init ---- */
  loadAll(function () {
    loadingEl.style.display = "none";
    scrubEl.min = SKIP;
    scrubEl.max = state.meta.n_timesteps - 1;
    scrubEl.value = SKIP;
    state.frame = SKIP;
    drawColorbar();
    renderFrame();
  });
})();
</script>

<p>
The Lyapunov exponent converges with grid refinement, is insensitive to perturbation magnitude, and is consistent across different initial planforms. It scales with migration rate but is invariant to the cutoff threshold. In short: cutoffs alone are sufficient for chaos, and they impose a finite predictability horizon on river planform evolution.
</p>

<p>
By Brayden Noh (Harvard, Dept. of Earth and Planetary Sciences) and Omar Wani (NYU Tandon School of Engineering).
</p>
