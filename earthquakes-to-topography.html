---
layout: default
title:  Earthquakes to Topography
---

<p>
<a href="index.html">Brayden Noh</a>
</p>

<h1>Earthquake Cycles to Topography</h1>

<p>
This simulator models topographic evolution over a planar reverse fault using the stream power equation.
Uplift is partitioned into steady <b>interseismic creeping</b> (deep fault) and sudden <b>coseismic rupture</b> (shallow fault) driven by the accumulated slip deficit. Adjust the cycle time to see how earthquake frequency and magnitude affect terrace formation.
</p>

<style>
  .controls {
    display: flex; align-items: flex-start; gap: 20px; margin-bottom: 20px;
    padding: 15px 20px; background: #f1f3f5; border-radius: 6px;
  }
  .button-group {
    display: flex; gap: 8px; margin-top: 5px;
  }
  .controls button {
    padding: 8px 16px; border: none; border-radius: 4px;
    background: #3498db; color: #fff; font-weight: bold; cursor: pointer; transition: 0.2s;
  }
  .controls button:hover:not(:disabled) { background: #2980b9; }
  .controls button:disabled { background: #bdc3c7; cursor: not-allowed; }

  .sliders-container {
    display: flex; flex-direction: column; gap: 12px; flex: 1;
  }
  .slider-group { display: flex; align-items: center; gap: 12px; }
  .slider-group label { font-weight: 600; font-size: 14px; color: #2c3e50; min-width: 220px; }
  .slider-group input { flex: 1; cursor: pointer; }
  .slider-val { font-family: monospace; font-size: 14px; font-weight: bold; color: #e74c3c; width: 60px; text-align: right; }

  .info-bar {
    display: flex; gap: 25px; font-size: 14px; color: #555;
    margin-bottom: 15px; font-weight: 500; border-bottom: 1px solid #eee; padding-bottom: 10px;
  }
  .info-bar span strong { color: #2980b9; font-family: monospace; font-size: 15px; }
  .plot-title { font-size: 14px; font-weight: 600; color: #34495e; margin: 15px 0 5px 0; }
  #sim-container canvas { width: 100%; height: auto; display: block; }
</style>

<div class="controls">
  <div class="button-group">
    <button id="btn-play">Play</button>
    <button id="btn-pause" disabled>Pause</button>
    <button id="btn-reset">Reset</button>
  </div>
  <div class="sliders-container">
    <div class="slider-group">
      <label for="sl-interval">Earthquake Cycle (Slip Deficit):</label>
      <input id="sl-interval" type="range" min="0" max="10010" step="10" value="100">
      <div class="slider-val" id="val-interval">100 yr</div>
    </div>
    <div class="slider-group">
      <label for="sl-speed">Simulation Speed:</label>
      <input id="sl-speed" type="range" min="1" max="50" step="1" value="5">
      <div class="slider-val" id="val-speed">5x</div>
    </div>
  </div>
</div>

<div class="info-bar">
  <span>Time: <strong id="info-time">0</strong> yr</span>
  <span>Earthquakes: <strong id="info-eq">0</strong></span>
  <span>Next EQ in: <strong id="info-next">100</strong> yr</span>
  <span>Max Elevation: <strong id="info-maxz">0.0</strong> m</span>
</div>

<div id="sim-container">
  <div class="plot-title">Topography Evolution</div>
  <canvas id="canvas-topo"></canvas>

  <div class="plot-title">Fault Geometry &amp; Activity</div>
  <canvas id="canvas-fault"></canvas>
</div>

<script>
(function () {
"use strict";

/* ================================================================
   Section 0: Precomputed Data & Constants
   ================================================================ */
// Uplift arrays (mm/yr), planar fault (0,0)-(10,-3), halfway transition
// Only first 26 values vary; rest are constant tail value
var UPLIFT_RED_PREFIX = [1.7033,0.3117,0.3688,0.4423,0.5385,0.6672,0.8428,1.0872,1.4319,1.9179,2.5800,3.3923,4.1831,4.6700,4.7302,4.5117,4.2140,3.9416,3.7228,3.5549,3.4273,3.3298,3.2545,3.1955,3.1488,3.1112];
var UPLIFT_RED_TAIL = 3.1112;
var UPLIFT_BLUE_PREFIX = [1.1702,2.5618,2.5047,2.4312,2.3349,2.2062,2.0306,1.7863,1.4416,0.9555,0.2935,-0.5188,-1.3096,-1.7965,-1.8567,-1.6383,-1.3405,-1.0681,-0.8494,-0.6814,-0.5538,-0.4563,-0.3810,-0.3221,-0.2753,-0.2377];
var UPLIFT_BLUE_TAIL = -0.2377;

// Planar fault geometry: (0,0) to (10,-3), 100 nodes
var FAULT_X = [0.0000,0.1010,0.2020,0.3030,0.4040,0.5051,0.6061,0.7071,0.8081,0.9091,1.0101,1.1111,1.2121,1.3131,1.4141,1.5152,1.6162,1.7172,1.8182,1.9192,2.0202,2.1212,2.2222,2.3232,2.4242,2.5253,2.6263,2.7273,2.8283,2.9293,3.0303,3.1313,3.2323,3.3333,3.4343,3.5354,3.6364,3.7374,3.8384,3.9394,4.0404,4.1414,4.2424,4.3434,4.4444,4.5455,4.6465,4.7475,4.8485,4.9495,5.0505,5.1515,5.2525,5.3535,5.4545,5.5556,5.6566,5.7576,5.8586,5.9596,6.0606,6.1616,6.2626,6.3636,6.4646,6.5657,6.6667,6.7677,6.8687,6.9697,7.0707,7.1717,7.2727,7.3737,7.4747,7.5758,7.6768,7.7778,7.8788,7.9798,8.0808,8.1818,8.2828,8.3838,8.4848,8.5859,8.6869,8.7879,8.8889,8.9899,9.0909,9.1919,9.2929,9.3939,9.4949,9.5960,9.6970,9.7980,9.8990,10.0000];
var FAULT_Z = [-0.0000,-0.0303,-0.0606,-0.0909,-0.1212,-0.1515,-0.1818,-0.2121,-0.2424,-0.2727,-0.3030,-0.3333,-0.3636,-0.3939,-0.4242,-0.4545,-0.4848,-0.5152,-0.5455,-0.5758,-0.6061,-0.6364,-0.6667,-0.6970,-0.7273,-0.7576,-0.7879,-0.8182,-0.8485,-0.8788,-0.9091,-0.9394,-0.9697,-1.0000,-1.0303,-1.0606,-1.0909,-1.1212,-1.1515,-1.1818,-1.2121,-1.2424,-1.2727,-1.3030,-1.3333,-1.3636,-1.3939,-1.4242,-1.4545,-1.4848,-1.5152,-1.5455,-1.5758,-1.6061,-1.6364,-1.6667,-1.6970,-1.7273,-1.7576,-1.7879,-1.8182,-1.8485,-1.8788,-1.9091,-1.9394,-1.9697,-2.0000,-2.0303,-2.0606,-2.0909,-2.1212,-2.1515,-2.1818,-2.2121,-2.2424,-2.2727,-2.3030,-2.3333,-2.3636,-2.3939,-2.4242,-2.4545,-2.4848,-2.5152,-2.5455,-2.5758,-2.6061,-2.6364,-2.6667,-2.6970,-2.7273,-2.7576,-2.7879,-2.8182,-2.8485,-2.8788,-2.9091,-2.9394,-2.9697,-3.0000];
var FAULT_ACTIVE_CUT = 50;

var NX = 501;
var X_END = 10.0; // km
var DX = X_END / (NX - 1); // 0.02 km
var K = 1e-4;
var M_EXP = 0.3;
var N_EXP = 1.0;
var H_EXP = 1.67;
var DT = 1; // 1 year per step
var STEPS_PER_FRAME = 5; // Default speed multiplier

// Build dense uplift arrays from prefix + constant tail (mm/yr -> km/yr)
var upliftRed = new Float64Array(NX);
var upliftBlue = new Float64Array(NX);
var xGrid = new Float64Array(NX);
var DA = new Float64Array(NX);

for (var i = 0; i < NX; i++) {
  xGrid[i] = i * DX;
  var redVal = (i < UPLIFT_RED_PREFIX.length) ? UPLIFT_RED_PREFIX[i] : UPLIFT_RED_TAIL;
  var blueVal = (i < UPLIFT_BLUE_PREFIX.length) ? UPLIFT_BLUE_PREFIX[i] : UPLIFT_BLUE_TAIL;
  upliftRed[i]  = redVal * 1e-6;
  upliftBlue[i] = blueVal * 1e-6;
  var Lx = X_END - xGrid[i];
  DA[i] = Math.max(Math.pow(Math.max(Lx, 0), H_EXP), 1.0);
}

/* ================================================================
   Section 1: DOM Refs & Canvas Setup
   ================================================================ */
var canvasTopo  = document.getElementById("canvas-topo");
var canvasFault = document.getElementById("canvas-fault");
var DPR = window.devicePixelRatio || 1;

function initCanvas(canvas, w, h) {
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w * DPR;
    canvas.height = h * DPR;
    var ctx = canvas.getContext("2d");
    ctx.scale(DPR, DPR);
    return ctx;
}

var ctxTopo = initCanvas(canvasTopo, 840, 260);
var ctxFault = initCanvas(canvasFault, 840, 200);

var btnPlay  = document.getElementById("btn-play");
var btnPause = document.getElementById("btn-pause");
var btnReset = document.getElementById("btn-reset");
var slInterval = document.getElementById("sl-interval");
var valInterval = document.getElementById("val-interval");
var slSpeed = document.getElementById("sl-speed");
var valSpeed = document.getElementById("val-speed");
var infoTime = document.getElementById("info-time");
var infoMaxZ = document.getElementById("info-maxz");
var infoEq   = document.getElementById("info-eq");
var infoNext = document.getElementById("info-next");

/* ================================================================
   Section 2: TVD Solver & Utilities
   ================================================================ */

function getNiceTicks(min, max, numTicks) {
    var range = max - min;
    if (range === 0) return [min];
    var step = Math.pow(10, Math.floor(Math.log10(range / numTicks)));
    var err = numTicks / (range / step);
    if (err <= .15) step *= 10;
    else if (err <= .35) step *= 5;
    else if (err <= .75) step *= 2;
    var ticks = [];
    var start = Math.ceil(min / step) * step;
    for (var val = start; val <= max + 1e-9; val += step) {
        ticks.push(parseFloat(val.toPrecision(10)));
    }
    return ticks;
}

function fillDepressions(z) {
  // Forces elevation to be monotonically increasing from left to right
  var max_val = z[0];
  for (var i = 1; i < z.length; i++) {
    if (z[i] < max_val) {
        z[i] = max_val;
    } else {
        max_val = z[i];
    }
  }
}

function tvdErosionStep(z, dx, dtMacro, Ke, m, n, DA, cfl) {
    var nx = z.length;
    var a = new Float64Array(nx);

    // Wave speed a = K * A^m * (dz/dx)^{n-1}
    // Wave travels left to right (a > 0)
    for (var i = 0; i < nx; i++) {
        var slope = (i < nx - 1) ? ((z[i+1] - z[i]) / dx) : ((z[i] - z[i-1]) / dx);
        if (slope < 0) slope = 0;

        var c = Ke * Math.pow(Math.max(DA[i], 1e-12), m);
        if (n !== 1.0) c = c * Math.pow(slope, n - 1.0);
        a[i] = c;
    }

    var a_max = 0;
    for (var i = 0; i < nx; i++) { if (a[i] > a_max) a_max = a[i]; }

    var dt_sub = dtMacro;
    if (a_max > 0) {
        var dt_allow = cfl * dx / a_max;
        if (dt_allow < dt_sub) dt_sub = dt_allow;
    }

    var steps = Math.ceil(dtMacro / dt_sub);
    dt_sub = dtMacro / steps;

    var z_new = new Float64Array(nx);
    var r = new Float64Array(nx);
    var phi = new Float64Array(nx);

    for (var s = 0; s < steps; s++) {
        for (var i = 0; i < nx; i++) {
            var dz_local = (i < nx - 1) ? (z[i+1] - z[i]) : 0;
            var dz_up = (i > 0) ? (z[i] - z[i-1]) : 0;
            if (Math.abs(dz_local) > 1e-12) r[i] = dz_up / dz_local;
            else r[i] = 1.0;
        }

        for (var i = 0; i < nx; i++) {
            phi[i] = (r[i] + Math.abs(r[i])) / (1.0 + Math.abs(r[i]));
        }

        for (var i = 1; i < nx - 1; i++) {
            var a_val = a[i];
            var z_val = z[i];
            var zr_val = z[i+1];
            var zl_val = z[i-1];

            var phi_R = phi[i];     // limiter at i+1/2
            var phi_L = phi[i-1];   // limiter at i-1/2

            var Fr_low = a_val * z_val;
            var Fr_high = 0.5 * a_val * (z_val + zr_val) - 0.5 * a_val * a_val * (dt_sub / dx) * (zr_val - z_val);
            var Fr = Fr_low + phi_R * (Fr_high - Fr_low);

            var Fl_low = a_val * zl_val;
            var Fl_high = 0.5 * a_val * (zl_val + z_val) - 0.5 * a_val * a_val * (dt_sub / dx) * (z_val - zl_val);
            var Fl = Fl_low + phi_L * (Fl_high - Fl_low);

            z_new[i] = z[i] - (dt_sub / dx) * (Fr - Fl);
        }
        z_new[0] = 0.0;
        z_new[nx-1] = z_new[nx-2]; // Divide mirrors neighbor to prevent spike

        for (var i = 0; i < nx; i++) z[i] = Math.max(0, z_new[i]);
    }
    return z;
}

/* ================================================================
   Section 3: Plot Rendering (Matplotlib-style)
   ================================================================ */
var PAD = { left: 60, right: 20, top: 20, bottom: 40 };

function makePlotTransform(cw, ch, xMin, xMax, yMin, yMax) {
  var pw = cw - PAD.left - PAD.right;
  var ph = ch - PAD.top - PAD.bottom;
  return {
    xMin: xMin, xMax: xMax, yMin: yMin, yMax: yMax, pw: pw, ph: ph,
    toCanvasX: function (x) { return PAD.left + (x - xMin) / (xMax - xMin) * pw; },
    toCanvasY: function (y) { return PAD.top + (1 - (y - yMin) / (yMax - yMin)) * ph; }
  };
}

function drawAxes(ctx, t, xLabel, yLabel, xTicks, yTicks, yTickLabels) {
    if (!yTickLabels) yTickLabels = yTicks;

    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1.5;
    ctx.beginPath();

    var x0 = t.toCanvasX(t.xMin);
    var x1 = t.toCanvasX(t.xMax);
    var y0 = t.toCanvasY(t.yMin);
    var y1 = t.toCanvasY(t.yMax);

    ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); // X axis
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); // Y axis
    ctx.stroke();

    ctx.fillStyle = "#333";
    ctx.font = "12px sans-serif";

    // X ticks
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for(var i=0; i<xTicks.length; i++) {
        var x = xTicks[i];
        var cx = t.toCanvasX(x);
        ctx.beginPath(); ctx.moveTo(cx, y0); ctx.lineTo(cx, y0+5); ctx.stroke();
        ctx.fillText(x, cx, y0+8);
    }
    ctx.fillText(xLabel, (x0+x1)/2, y0 + 25);

    // Y ticks
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(var i=0; i<yTicks.length; i++) {
        var y = yTicks[i];
        var lbl = yTickLabels[i];
        var cy = t.toCanvasY(y);
        ctx.beginPath(); ctx.moveTo(x0, cy); ctx.lineTo(x0-5, cy); ctx.stroke();
        ctx.fillText(lbl, x0-8, cy);
    }

    ctx.save();
    ctx.translate(x0 - 45, (y0+y1)/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
}

function renderTopo(topoZ, rawZ) {
  var cw = canvasTopo.width / DPR, ch = canvasTopo.height / DPR;

  var zMax = 0;
  for (var i = 0; i < NX; i++) { if (topoZ[i] > zMax) zMax = topoZ[i]; }
  zMax = Math.max(zMax, 0.005) * 1.2; // Min 6 meters dynamic scale
  var zMin = 0;

  var t = makePlotTransform(cw, ch, 0, X_END, zMin, zMax);
  ctxTopo.clearRect(0, 0, cw, ch);

  var yTicksKm = getNiceTicks(zMin, zMax, 4);
  var yTicksM = yTicksKm.map(function(y) { return (y * 1000).toFixed(1); });

  drawAxes(ctxTopo, t, "Distance from MFT (km)", "Elevation (m)", [0, 2, 4, 6, 8, 10], yTicksKm, yTicksM);

  // Terrain Fill (Gray)
  ctxTopo.fillStyle = "rgba(180, 180, 180, 0.5)";
  ctxTopo.beginPath();
  ctxTopo.moveTo(t.toCanvasX(xGrid[0]), t.toCanvasY(0));
  for (var i = 0; i < NX; i++) {
    ctxTopo.lineTo(t.toCanvasX(xGrid[i]), t.toCanvasY(topoZ[i]));
  }
  ctxTopo.lineTo(t.toCanvasX(xGrid[NX - 1]), t.toCanvasY(0));
  ctxTopo.closePath();
  ctxTopo.fill();

  // Lake fill overlay (blue fill to indicate fill areas)
  if (rawZ) {
    ctxTopo.fillStyle = "rgba(41, 128, 185, 0.6)";
    ctxTopo.beginPath();
    ctxTopo.moveTo(t.toCanvasX(xGrid[0]), t.toCanvasY(topoZ[0]));
    for (var i = 1; i < NX; i++) {
      ctxTopo.lineTo(t.toCanvasX(xGrid[i]), t.toCanvasY(topoZ[i]));
    }
    for (var i = NX - 1; i >= 0; i--) {
      ctxTopo.lineTo(t.toCanvasX(xGrid[i]), t.toCanvasY(rawZ[i]));
    }
    ctxTopo.closePath();
    ctxTopo.fill();
  }

  // Topographic Line (Black)
  ctxTopo.strokeStyle = "#000000";
  ctxTopo.lineWidth = 2;
  ctxTopo.beginPath();
  for (var i = 0; i < NX; i++) {
    var px = t.toCanvasX(xGrid[i]);
    var py = t.toCanvasY(topoZ[i]);
    if (i === 0) ctxTopo.moveTo(px, py); else ctxTopo.lineTo(px, py);
  }
  ctxTopo.stroke();
}

function renderFault(eqFlash) {
  var cw = canvasFault.width / DPR, ch = canvasFault.height / DPR;
  var t = makePlotTransform(cw, ch, 0, 10, -3.5, 0.5);

  ctxFault.clearRect(0, 0, cw, ch);

  var yTicks = [-3, -2, -1, 0];
  drawAxes(ctxFault, t, "Distance from MFT (km)", "Depth (km)", [0, 2, 4, 6, 8, 10], yTicks);

  var colorActive = "#e74c3c", colorInactive = "#95a5a6";
  var widthActive = 3.5, widthInactive = 1.5;

  var eqInterval = getInterval();
  var allActive = (eqInterval === 0); // Steady state: entire fault creeping

  var colorShallow = allActive ? colorActive : (eqFlash ? colorActive : colorInactive);
  var widthShallow = allActive ? widthActive : (eqFlash ? widthActive : widthInactive);

  var colorDeep = allActive ? colorActive : ((!eqFlash) ? colorActive : colorInactive);
  var widthDeep = allActive ? widthActive : ((!eqFlash) ? widthActive : widthInactive);

  // Draw Deep (Creeping)
  ctxFault.strokeStyle = colorDeep;
  ctxFault.lineWidth = widthDeep;
  ctxFault.beginPath();
  for (var i = FAULT_ACTIVE_CUT; i < FAULT_X.length; i++) {
    var cx = t.toCanvasX(FAULT_X[i]);
    var cy = t.toCanvasY(FAULT_Z[i]);
    if (i === FAULT_ACTIVE_CUT) ctxFault.moveTo(cx, cy);
    else ctxFault.lineTo(cx, cy);
  }
  ctxFault.stroke();

  // Draw Shallow (Locked)
  ctxFault.strokeStyle = colorShallow;
  ctxFault.lineWidth = widthShallow;
  ctxFault.beginPath();
  for (var i = 0; i <= FAULT_ACTIVE_CUT; i++) {
    var cx = t.toCanvasX(FAULT_X[i]);
    var cy = t.toCanvasY(FAULT_Z[i]);
    if (i === 0) ctxFault.moveTo(cx, cy);
    else ctxFault.lineTo(cx, cy);
  }
  ctxFault.stroke();

}

/* ================================================================
   Section 4: Simulation State & Loop
   ================================================================ */
var topoZ = new Float64Array(NX);
var rawZ  = new Float64Array(NX);
var simTime = 0;
var eqCount = 0;
var timeSinceLastEq = 0;
var eqFlashFrames = 0;
var playing = false;
var animFrameId = null;

function getInterval() { return parseInt(slInterval.value); }

function doStep() {
  var eqInterval = getInterval();

  if (eqInterval === 0) {
    // STEADY STATE: apply full structural rate (red + blue) every step
    for (var i = 1; i < NX; i++) {
      topoZ[i] += (upliftRed[i] + upliftBlue[i]) * DT;
    }
  } else if (eqInterval > 10000) {
    // NEVER: only interseismic, coseismic never releases
    for (var i = 1; i < NX; i++) {
      topoZ[i] += upliftRed[i] * DT;
    }
  } else {
    // Normal earthquake cycle
    // 1. Interseismic Uplift
    for (var i = 1; i < NX; i++) {
      topoZ[i] += upliftRed[i] * DT;
    }
    // 2. Check Earthquake Trigger
    timeSinceLastEq += DT;
    if (timeSinceLastEq >= eqInterval) {
      for (var i = 1; i < NX; i++) {
        topoZ[i] += upliftBlue[i] * eqInterval;
      }
      timeSinceLastEq = 0;
      eqCount++;
      eqFlashFrames = 15;
    }
  }

  // 3. Fluvial Erosion (TVD Step)
  topoZ = tvdErosionStep(topoZ, DX, DT, K, M_EXP, N_EXP, DA, 0.9);

  // 4. Save Raw Z and Fill Depressions
  for (var i = 0; i < NX; i++) { rawZ[i] = topoZ[i]; }
  fillDepressions(topoZ);

  simTime += DT;
}

function updateInfo() {
  var eqInterval = getInterval();
  infoTime.textContent = simTime;
  var maxZ = 0;
  for (var i = 0; i < NX; i++) if (topoZ[i] > maxZ) maxZ = topoZ[i];
  infoMaxZ.textContent = (maxZ * 1000).toFixed(2);
  infoEq.textContent = eqCount;
  if (eqInterval === 0) {
    infoNext.textContent = "N/A";
  } else if (eqInterval > 10000) {
    infoNext.textContent = "Never";
  } else {
    infoNext.textContent = Math.max(0, eqInterval - timeSinceLastEq);
  }
}

function animate() {
  if (!playing) return;

  for (var s = 0; s < STEPS_PER_FRAME; s++) {
    doStep();
  }

  var flash = eqFlashFrames > 0;
  if (eqFlashFrames > 0) eqFlashFrames--;

  renderTopo(topoZ, rawZ);
  renderFault(flash);
  updateInfo();

  animFrameId = requestAnimationFrame(animate);
}

function play() {
  playing = true;
  btnPlay.disabled = true;
  btnPause.disabled = false;
  animFrameId = requestAnimationFrame(animate);
}

function pause() {
  playing = false;
  btnPlay.disabled = false;
  btnPause.disabled = true;
  if (animFrameId) cancelAnimationFrame(animFrameId);
}

function reset() {
  pause();
  simTime = 0;
  eqCount = 0;
  timeSinceLastEq = 0;
  eqFlashFrames = 0;
  topoZ = new Float64Array(NX);
  rawZ  = new Float64Array(NX);
  renderTopo(topoZ, rawZ);
  renderFault(false);
  updateInfo();
}

/* ================================================================
   Section 5: Wiring & Initial Render
   ================================================================ */
btnPlay.addEventListener("click", play);
btnPause.addEventListener("click", pause);
btnReset.addEventListener("click", reset);

function intervalLabel(v) {
  if (v === 0) return "Steady State";
  if (v > 10000) return "Never";
  return v + " yr";
}

slInterval.addEventListener("input", function () {
  valInterval.textContent = intervalLabel(parseInt(slInterval.value));
  updateInfo();
});

slSpeed.addEventListener("input", function () {
  valSpeed.textContent = slSpeed.value + "x";
  STEPS_PER_FRAME = parseInt(slSpeed.value);
});

renderTopo(topoZ, rawZ);
renderFault(false);
updateInfo();

})();
</script>
